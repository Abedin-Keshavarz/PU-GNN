# -*- coding: utf-8 -*-
"""PU-GNN .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f2GnetrsVuDBdJgWGrevCNyKDpiTDpWx
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/My Drive/project
!pwd

# Load libraries
import pandas as pd
import numpy as np
from sklearn.decomposition import PCA
import random
import time
import csv
import os
import sys
from sklearn.model_selection import train_test_split # Import train_test_split function
from sklearn import metrics #Import scikit-learn metrics module for accuracy calculation

datamono = pd.read_csv("biomono.csv")

dataset1 = datamono.values
datacombo = pd.read_csv("bio-decagon-combo.csv")#biocombo

dataset2 = datacombo.values

x1combo=dataset2[:,1]
x2combo=dataset2[:,0]
drag_list= []
dic_dragcode={}
dic_indragcode={}

xm1drag=dataset1[:,1]
d=0
for i in range(len(xm1drag)):
  if xm1drag[i] not in drag_list:
    drag_list.append(xm1drag[i])
    dic_dragcode[xm1drag[i]] = d
    dic_indragcode[d]=xm1drag[i]
    d+=1
for i in range(len(x1combo)):
  if x1combo[i] not in drag_list:
    drag_list.append(x1combo[i])
    dic_dragcode[x1combo[i]] = d
    dic_indragcode[d]=x1combo[i]
    d+=1
  if x2combo[i] not in drag_list:
    drag_list.append(x2combo[i])
    dic_dragcode[x2combo[i]] = d
    dic_indragcode[d]=x2combo[i]
    d+=1

data_biomono =dataset1
data_biocombo =dataset2

datacombo = pd.read_csv("bio-decagon-combo.csv")
number=500
dataset2 = datacombo.values
ysid=dataset2[:,2]
side_list01= []
side_list1= []
side_set=set()
dic_sidcode1={}
dic_sidcode01={}

dic_insidcode01={}
dic_insidcode1={}
si=0
s=0
p=0
counter=np.zeros((len(side_set)))

for i in range(len(ysid)):
  #if ysid[i] in side_list0:
    if ysid[i] not in side_list01:
      side_set.add(ysid[i])
      side_list01.append(ysid[i])
      dic_sidcode01[ysid[i]] = si
      dic_insidcode01[si] = ysid[i]
      si+=1

counter1=np.zeros((len(side_set)))
counter=[]
for i in range(len(ysid)):
  counter1[dic_sidcode01[ysid[i]]]+=1

NO_side=0

for i in range(len(counter1)):
  if  counter1[i]>=number:
    NO_side+=1
for i in range(len(ysid)):
  if counter1[dic_sidcode01[ysid[i]]]>=number:
    p+=1
    if ysid[i] not in side_list1:
      side_set.add(ysid[i])
      side_list1.append(ysid[i])
      dic_sidcode1[ysid[i]] = s
      dic_insidcode1[s] = ysid[i]
      counter.append(counter1[dic_sidcode01[ysid[i]]])
      s+=1

def load_training_data(f_name):
    print('We are loading data from:', f_name)
    words = []
    with open(f_name, 'r') as f:
        for line in f:
            word = line[:-1].split(' ')
            words.append(([word]))
            print(line)
    return words

def save_walks(walk_file, test):
    with open( walk_file, 'w') as f:
      for line in range(len(test)):
            words = test[line]
            f.write(' '.join([str(x) for x in words]) + '\n')

data_target = pd.read_csv("bio-decagon-targets-all.csv")
data_target

dataset = data_target.values
side_list= []
data_target=[]
target_list=[]
dic_target={}
dic_intarget={}
dic_Disease={}
ysid=dataset[:,0]
target =dataset[:,1]
y_Disease = dataset[:,1]
p=0
for i in range(len(ysid)):
  if ysid[i] in drag_list:
    data_target.append(dataset[i,:])
    if target[i] not in target_list:
      target_list.append(target[i])
      dic_target[target[i]] = p
      dic_intarget[p] = target[i]
      p+=1

matrix_target = np.zeros((len(drag_list),len(target_list)))
matrix_target.shape

for i in range(len(data_target)):
  dt = data_target[i]
  d = dt[0]
  t = dt[1]
  matrix_target[dic_dragcode[d],dic_target[t]] = int(1)

def SPP(matrix):

  import pandas as pd
  import numpy as np
  import random
  set_begin=[]
  set_end=[]
  set_end1=[]
  test=0
  sets=[]
  d = len(matrix)
  feture_matrix =np.zeros( (d, d) )
  feture_matrix1 =[d, d]
  for i in range(len(matrix)):
    for j in range(len(matrix)):
      feture_matrix[i,j] =int(0)
  s=0
  k1=0
  tr=0
  for i in range(len(matrix)):
    s=0
    tr=0
    set_begin=[]
    set_end=[]
    set_end1=[]
    test=0
    for j in range(len(matrix[i])):
      set_end1=[]
      set_begin=[]
      if matrix[i,j]==1:
        for k in range(len(matrix)):
          if matrix[k,j]==1:
            set_begin.append(k)
        if s==0:
          set_end=set_begin
          s=1
        if s==1:
          for p in range(len(matrix[i])):
            if (p in set_end) and (p in set_begin):
              set_end1.append(p)
          set_end =set_end1

    tr1=0
    for p in range(len(sets)):
      if set_end==sets[p]:
        tr1=1
    if tr1==0:
      for p in range(len(matrix)):
        if p not in set_end:
          feture_matrix[p, k1]=int(0)
        if p in set_end:
          feture_matrix[p, k1]=int(1)
          tr =1
      if tr ==1 :
        tr=0
        k1+=1
  return feture_matrix,k1

matrix_target1 =np.zeros( (645, 645) )

matrix_target11, k= SPP(matrix_target)

matrix_target1 =np.zeros( (645, k) )
for j in range(len(matrix_target11)):
  s=matrix_target1[j]
  d=matrix_target11[j]
  for p in range(k):
    s[p]=d[p]

!pip install pulearn

def pu_learn(a):
  from pulearn import ElkanotoPuClassifier
  import numpy as np
  #from sklearn.svm import SVC
  import numpy as np
  import pytest
  from sklearn.datasets import make_classification
  from sklearn.naive_bayes import GaussianNB
  #from sklearn.tree import DecisionTreeClassifier
  #from sklearn.ensemble import RandomForestClassifier
  #from sklearn.neighbors import KNeighborsClassifier
  #from sklearn.linear_model import (LogisticRegression,Perceptron,)
  from sklearn.exceptions import NotFittedError

  from pulearn import (
      BaggingPuClassifier,
  )
  x1=[]
  x2=[]
  y=[]
  x=[]
  y1=[]
  CV=0
  l= 0
  x=[]
  y_pu=[]
  data=[]
  p =207690
  x1 =[]
  x2 =[]
  for i in range(len(a)):
    for j in range(i+1, len(a)):
      d=[]
      b=[]
      if a[i, j] == 1:
                y.append(int(1))
                data.append([i,j])
                d = (matrix_target_[i])
                b = (matrix_target_[j])


      else:
                y.append(int(-1))
                data.append([i,j])
                d = (matrix_target_[i])
                b = (matrix_target_[j])

      x1.append(d)
      x2.append(b)
      l+=1
      d=[]
      b=[]
  x1 =np.array(x1)
  x2 =np.array(x2)
  y =np.array(y)
  x1 = np.concatenate((np.array(x1), x2), axis=1)

  estimator = GaussianNB()
  pu_estimator = ElkanotoPuClassifier(estimator, hold_out_ratio=0.9)
  pu_estimator.fit(x1, y)
  pu_estimator.predict(x1)
  len(np.where((pu_estimator.predict(x1) == estimator.predict(x1)) == False)[0])
  len(np.where((pu_estimator.predict(x1) == estimator.predict(x1)) == True)[0])  # noqa: E712
  y_pu=pu_estimator.predict(x1)
  y1=estimator.predict(x1)

  return y_pu

def matrix(j, data_biocombo, allside, dic_sidcode1,dic_dragcode):
  import numpy as np
  matrix_2drag_side = np.zeros((645,645))

  for i in range(len(data_biocombo)):
    dt= data_biocombo[i]
    i1 = dt[2]
    d1 = dt[1]
    d2 = dt[0]
    if i1 in (side_list1):
      if (dic_sidcode1[i1]==j):
        matrix_2drag_side[dic_dragcode[d1], dic_dragcode[d2]] = 1
        matrix_2drag_side[dic_dragcode[d2], dic_dragcode[d1]] = 1

  return matrix_2drag_side

def pos_all_pu(a, data, CV_num):
  print("fold_num", CV_num)
  fold_num=0
  non_fold_num=0
  count=0
  trainPosition=[]
  trainPosition0=[]
  all_pos=[]
  validPosition=[]
  testPosition=[]
  drag=[]
  validPosition0=[]
  puPosition=[]
  testPosition0=[]
  trainPosition1=[]
  validPosition1=[]
  testPosition1=[]
  link_number = 0
  nonLinksPosition1 = []
  nonLinksPosition = [] # all non-link position
  link_position = []
  CV=0
  f=0
  nl=0
  counter=0
  for i in range(len(a)):
        for j in range(i+1, len(a)):
          if (a[i, j] == 1) or (data[f]==1):

                link_number = link_number + 1
                link_position.append([i, j])
                counter+=1
                f+=1
          else:
                nonLinksPosition.append([1, i, j,0])
                nl+=1
                f+=1
  link_position = np.array(link_position)
  nonLinksPosition = np.array(nonLinksPosition)
  index = np.arange(0, len(link_position))
  random.shuffle(index)
  fold_num = len(link_position) // CV_num
  test_index = index[(CV * fold_num):((CV + 1) * fold_num)]
  valid_index = index[((CV+1) * fold_num):((CV + 2) * fold_num)]
  train_index = index[((CV+2) * fold_num): ]
  test_index.sort()
  train_index.sort()
  valid_index.sort()
  f=0
  for i in range(len(a)):
    for j in range(i+1, len(a)):
      if (a[i, j] == 1) or (data[f]==1):
          f+=1
          if (i in drag) and (j in drag):
            gf=[1, i, j, 1]
            testPosition.append(gf)
            validPosition.append(gf)
            gf=[1, i, j]
            trainPosition1.append(gf)
          else:
            gf=[1, i, j]
            trainPosition.append(gf)
            if i not in drag:
              drag.append(i)
            if j not in drag:
              drag.append(j)
      else:
          gf=[1, i, j, 0]
          nonLinksPosition1.append(gf)
          f+=1

  CV=0
  index = np.arange(0, len(testPosition))
  random.shuffle(index)
  fold_num = len(link_position) // CV_num
  non_fold_num = len(nonLinksPosition1) // CV_num
  test_index = index[(CV * fold_num):((CV + 1) * fold_num)]
  valid_index = index[((CV+1) * fold_num):((CV + 2) * fold_num)]
  train_index = index[((CV+2) * fold_num): ]
  test_index.sort()
  train_index.sort()
  valid_index.sort()
  if len(testPosition)> ((len(link_position) // CV_num)*2):
    testPosition = np.array(testPosition)[test_index]
    validPosition = np.array(validPosition)[valid_index]
    trainPosition1 = np.array(trainPosition1)[train_index]
    trainPosition = np.concatenate((np.array(trainPosition), trainPosition1), axis=0)
  else:
    index = np.arange(0, len(testPosition))
    random.shuffle(index)
    fold_num = len(testPosition) // 2
    test_index = index[(CV * fold_num):((CV + 1) * fold_num)]
    valid_index = index[((CV+1) * fold_num): ]
    test_index.sort()
    valid_index.sort()
    testPosition = np.array(testPosition)[test_index]
    validPosition = np.array(validPosition)[test_index]

  index = np.arange(0, len(nonLinksPosition))
  random.shuffle(index)
  count=link_number//(2*CV_num)
  nl//=2

  if count >= len(nonLinksPosition):
      nl = len(nonLinksPosition)
      nl//=2
      test_index = index[0:nl]
      valid_index = index[nl: ]
      testPosition2 = np.array(nonLinksPosition1)[test_index]
      validPosition2 = np.array(nonLinksPosition1)[valid_index]

      testPosition = np.concatenate((np.array(testPosition), testPosition2), axis=0)
      validPosition = np.concatenate((np.array(validPosition), validPosition2), axis=0)
  if count < len(nonLinksPosition):
      test_index = index[0:nl]
      valid_index = index[nl: ]
      train_index.sort()
      test_index.sort()
      valid_index.sort()
      testPosition2 = np.array(nonLinksPosition1)[test_index]
      validPosition2 = np.array(nonLinksPosition1)[valid_index]

      testPosition = np.concatenate((np.array(testPosition), testPosition2), axis=0)
      validPosition = np.concatenate((np.array(validPosition), validPosition2), axis=0)

  return (trainPosition, validPosition, testPosition)

def pos_pu(a, data, CV_num):
  print("fold_num", CV_num)
  fold_num=0
  non_fold_num=0
  count=0
  trainPosition=[]
  trainPosition0=[]
  all_pos=[]
  validPosition=[]
  testPosition=[]
  drag=[]
  validPosition0=[]
  puPosition=[]
  testPosition0=[]
  trainPosition1=[]
  validPosition1=[]
  testPosition1=[]
  link_number = 0
  nonLinksPosition1 = []
  nonLinksPosition = [] # all non-link position
  link_position = []
  CV=0
  f=0
  nl=0
  counter=0
  for i in range(len(a)):
        for j in range(i+1, len(a)):
          if (a[i, j] == 1) or (data[f]==1):

                link_number = link_number + 1
                link_position.append([i, j])
                counter+=1
                f+=1
          else:
                nonLinksPosition.append([1, i, j,0])
                nl+=1
                f+=1
  link_position = np.array(link_position)
  nonLinksPosition = np.array(nonLinksPosition)
  index = np.arange(0, len(link_position))
  random.shuffle(index)
  fold_num = len(link_position) // CV_num
  test_index = index[(CV * fold_num):((CV + 1) * fold_num)]
  valid_index = index[((CV+1) * fold_num):((CV + 2) * fold_num)]
  train_index = index[((CV+2) * fold_num): ]
  #train_index = np.setdiff1d(index, test_index)
  test_index.sort()
  train_index.sort()
  valid_index.sort()
  f=0
  for i in range(len(a)):
    for j in range(i+1, len(a)):
      if (a[i, j] == 1) or (data[f]==1):
          f+=1
          if (i in drag) and (j in drag):
            gf=[1, i, j, 1]
            testPosition.append(gf)
            validPosition.append(gf)
            gf=[1, i, j]
            trainPosition1.append(gf)
          else:
            gf=[1, i, j]
            trainPosition.append(gf)
            if i not in drag:
              drag.append(i)
            if j not in drag:
              drag.append(j)
      else:
          gf=[1, i, j, 0]
          nonLinksPosition1.append(gf)
          f+=1

  CV=0
  index = np.arange(0, len(testPosition))
  random.shuffle(index)
  fold_num = len(link_position) // CV_num
  non_fold_num = len(nonLinksPosition1) // CV_num
  test_index = index[(CV * fold_num):((CV + 1) * fold_num)]
  valid_index = index[((CV+1) * fold_num):((CV + 2) * fold_num)]
  train_index = index[((CV+2) * fold_num): ]
  test_index.sort()
  train_index.sort()
  valid_index.sort()
  if len(testPosition)> ((len(link_position) // CV_num)*2):
    testPosition = np.array(testPosition)[test_index]
    validPosition = np.array(validPosition)[valid_index]
    trainPosition1 = np.array(trainPosition1)[train_index]
    trainPosition = np.concatenate((np.array(trainPosition), trainPosition1), axis=0)
  else:
    index = np.arange(0, len(testPosition))
    random.shuffle(index)
    fold_num = len(testPosition) // 2
    test_index = index[(CV * fold_num):((CV + 1) * fold_num)]
    valid_index = index[((CV+1) * fold_num): ]
    test_index.sort()
    valid_index.sort()
    testPosition = np.array(testPosition)[test_index]
    validPosition = np.array(validPosition)[test_index]

  index = np.arange(0, len(nonLinksPosition))
  random.shuffle(index)
  count=link_number//(2*CV_num)
  nl//=2

  if count >= len(nonLinksPosition):
      nl = len(nonLinksPosition)
      nl//=2
      test_index = index[0:nl]
      valid_index = index[nl: ]
      testPosition2 = np.array(nonLinksPosition1)[test_index]
      validPosition2 = np.array(nonLinksPosition1)[valid_index]

      testPosition = np.concatenate((np.array(testPosition), testPosition2), axis=0)
      validPosition = np.concatenate((np.array(validPosition), validPosition2), axis=0)
  if count < len(nonLinksPosition):
      test_index = index[(CV * fold_num):((CV + 1) * fold_num)]#index[0:nl]
      valid_index = index[((CV + 1) * fold_num):((CV + 2) * fold_num)]#index[nl: ]
      train_index.sort()
      test_index.sort()
      valid_index.sort()
      testPosition2 = np.array(nonLinksPosition1)[test_index]
      validPosition2 = np.array(nonLinksPosition1)[valid_index]

      testPosition = np.concatenate((np.array(testPosition), testPosition2), axis=0)
      validPosition = np.concatenate((np.array(validPosition), validPosition2), axis=0)

  return (trainPosition, validPosition, testPosition)

pca = PCA(.95)
pca.fit(matrix_target)
#pca_= PCA(.95)
#pca_.fit(drug_protein_adj)
#matrix_target_ = pca.transform(matrix_target)
matrix_target_ = matrix_target1

# Commented out IPython magic to ensure Python compatibility.

exit_side = np.zeros( ((NO_side), 3) )
f1=np.zeros( ((NO_side)) )
ar=np.zeros( ((NO_side)) )
auc=np.zeros( ((NO_side)) )
matrix_neg = np.zeros((len(drag_list),len(drag_list)))
exit1=[]

r=0
b=[]
while r <1:#(len(NO_side)):
  valid=[]
  test=[]
  train=[]
  pu=[]
  a= matrix(r,data_biocombo, side_list1, dic_sidcode1, dic_dragcode)
  data = pu_learn(a)
  train, valid, test, = pos_pu(a, data, 10)
  #train, valid, test, = pos_all_pu(a, data, 10)

  save_walks("test.txt", test)
  time.sleep(1)
  save_walks("valid.txt", valid)
  time.sleep(1)
  save_walks("train.txt", train)
  time.sleep(1)
#   %cd /content/drive/My Drive/project
  !pwd
  !python main.py
  time.sleep(1)
#   %cd /content/drive/My Drive/project
  !pwd
  exit1 = load_training_data('exit0_1')
  l1=exit1[0]
  l=l1[0]
  print((l[0]))
  k1=(l[0])
  k2=(l[3])
  k3=(l[6])
  y1 =(float(k1))
  y2 =(float(k2))
  y3 =(float(k3))
  p= exit_side[r]
  auc[r]=y1
  ar[r]=y2
  f1[r]=y3

  exit_side[r]= [auc[r], ar[r], f1[r]]
  save_walks("all_side", exit_side)
  print("IIIIIIIIIIIIIII", r)

  r+=1

all_side1 = exit_side#load_training_data('all_side.txt')

roc_score=[]
aupr_score=[]
f_score=[]
for i in range(len(all_side1)):
  l=exit_side[i]
  roc_score.append(l[0])
  aupr_score.append(l[1])
  f_score.append(l[2])
print(np.mean(roc_score), np.mean(aupr_score),np.mean(f_score),)